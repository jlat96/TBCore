using System;
using System.Collections.Generic;
using TrailBlazer.TBOptimizer.Evaluation;
using TrailBlazer.TBOptimizer.State;

namespace TrailBlazer.TBOptimizer.Climber.Algorithm
{
    /// <summary>
    /// Chooses the most optimal from the neighbor states generated by any given <see cref="TState"/>.
    /// </summary>
    /// <typeparam name="TState">The type of state from which successors will be generated</typeparam>
    /// <typeparam name="TEvaluation">The type of object that will represent a states evaluation for comparison</typeparam>
    public class ClimberSuccessorSelector<TState, TEvaluation> : ISuccessorSelector<TState, TEvaluation>
        where TState : IEvaluable<TEvaluation>
        where TEvaluation: IComparable<TEvaluation>
    {
        private readonly Func<TState, IEnumerable<TState>> successorGenerationFunction;
        private readonly IComparer<TEvaluation> evaluationComparer;
        private readonly ISet<TState> encounteredStates;

        /// <summary>
        /// Creates a <see cref="ClimberSuccessorSelector{TState, TEvaluation}" that will create neighbor states using the given
        /// <see cref="ISuccessorGenerator{TState, TEvaluable}"/>/>
        /// </summary>
        /// <param name="generator">The complex SuccessorGenerator that will be used to generate neighbor states</param>
        /// <param name="evaluationComparer">The comparison strategy to determine which successor state is most optimal</param>
        public ClimberSuccessorSelector(ISuccessorGenerator<TState, TEvaluation> generator, IComparer<TEvaluation> evaluationComparer)
            : this(evaluationComparer, (c) => generator.GetSuccessors(c))
        {
        }

        /// <summary>
        /// Creates a <see cref="ClimberSuccessorSelector{TState, TEvaluation}" that will create neighbor states using the given
        /// generation function/>
        /// </summary>
        /// <param name="evaluationComparer">The comparison strategy to determine which successor state is most optimal</param>
        /// <param name="successorGenerationFunction">The function that will be invoked to generate neighbor states</param>
        public ClimberSuccessorSelector(IComparer<TEvaluation> evaluationComparer, Func<TState, IEnumerable<TState>> successorGenerationFunction)
        {
            this.evaluationComparer = evaluationComparer;
            this.successorGenerationFunction = successorGenerationFunction;
            encounteredStates = new HashSet<TState>();
        }

        /// <summary>
        /// Creates successor states from a given <see cref="TState"/> current and evaluates the most
        /// optimal state using the seletor's comparison strategy
        /// </summary>
        /// <param name="current">The state from which to get the next successor</param>
        /// <returns>The most optimal successor based on the supplied comparison strategy</returns>
        public TState Next(TState current)
        {
            TState bestSuccessor = successorGenerationFunction.Invoke(current).Extrema(evaluationComparer);

            bool stateEncountered;

            lock (encounteredStates)
            {
                stateEncountered = encounteredStates.Contains(bestSuccessor);
            }

            if (evaluationComparer.Compare(current.GetEvaluation(), bestSuccessor.GetEvaluation()) <= 0 ||
                stateEncountered)
            {
                return current;
            }

            lock (encounteredStates)
            {
                encounteredStates.Add(bestSuccessor);
            }

            return bestSuccessor;
        }
    }
}
